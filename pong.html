<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Simple Ping Pong</title>
    <style>
        /* Basic Reset & Body Style */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(45deg, #1a2a6c, #b21f1f, #fdbb2d);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            font-family: 'Arial', sans-serif;
            color: white;
            overflow: hidden; /* Prevent scrollbars caused by game area */
        }

        /* Background Animation */
        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Game Area */
        #gameArea {
            position: relative;
            width: 90vw; /* Use viewport width */
            max-width: 700px; /* Max width for large screens */
            height: 60vh; /* Use viewport height */
            max-height: 450px; /* Max height */
            border: 3px solid rgba(255, 255, 255, 0.7);
            background-color: rgba(0, 0, 0, 0.4); /* Semi-transparent black */
            overflow: hidden; /* Keep elements inside */
            cursor: none; /* Hide default cursor over game */
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 10px;
        }

        /* Paddles */
        .paddle {
            position: absolute;
            width: 12px;
            height: 80px;
            background-color: white;
            border-radius: 3px;
            top: calc(50% - 40px); /* Vertically center initially */
        }

        #paddleLeft { /* AI Paddle */
            left: 10px;
            background-color: #ff8080; /* Slightly different color for AI */
            box-shadow: 0 0 6px rgba(255, 100, 100, 0.8); /* Subtle red glow for AI */
        }

        #paddleRight { /* Player Paddle */
            right: 10px;
            background-color: #ffffff; /* Explicit white */
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.9); /* White glow for Player */
        }

        /* Ball */
        #ball {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: #ffcc00; /* Bright yellow */
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(255, 204, 0, 0.9);
            top: calc(50% - 7.5px); /* Center */
            left: calc(50% - 7.5px); /* Center */
        }

        /* Score Display */
        .score {
            position: absolute;
            top: 20px;
            font-size: 2.5em; /* Relative font size */
            font-weight: bold;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            user-select: none; /* Prevent text selection */
            transition: transform 0.2s ease-out; /* Add transition for score flash */
        }
        .score.flash { /* Style for flashing score */
             transform: scale(1.2);
             color: #ffcc00; /* Highlight color */
        }


        #scoreLeft { /* AI Score */
            left: 25%;
            transform: translateX(-50%);
        }

        #scoreRight { /* Player Score */
            right: 25%;
            transform: translateX(50%);
        }

        /* Center Line (Optional visual) */
        #centerLine {
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            background: repeating-linear-gradient(
                transparent,
                transparent 5px,
                rgba(255, 255, 255, 0.3) 5px,
                rgba(255, 255, 255, 0.3) 10px
            );
            transform: translateX(-50%);
        }

        /* Message Overlay */
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            font-size: 1.4em;
            text-align: center;
            display: block; /* Initially shown */
            z-index: 10;
            cursor: pointer;
            user-select: none;
            line-height: 1.4;
        }
    </style>
</head>
<body>

    <div id="gameArea">
        <div id="centerLine"></div>
        <div id="paddleLeft" class="paddle"></div>  <!-- AI Paddle -->
        <div id="paddleRight" class="paddle"></div> <!-- Player Paddle -->
        <div id="ball"></div>
        <div id="scoreLeft" class="score">0</div>   <!-- AI Score -->
        <div id="scoreRight" class="score">0</div>  <!-- Player Score -->
        <div id="message">First 10 points wins!<br>Click or Tap to Play</div>
    </div>

    <script>
        // --- DOM Elements ---
        const gameArea = document.getElementById('gameArea');
        const paddleLeft = document.getElementById('paddleLeft');    // AI Paddle
        const paddleRight = document.getElementById('paddleRight');  // Player Paddle
        const ball = document.getElementById('ball');
        const scoreLeftDisplay = document.getElementById('scoreLeft'); // AI Score Display
        const scoreRightDisplay = document.getElementById('scoreRight');// Player Score Display
        const message = document.getElementById('message');

        // --- Game Variables ---
        let ballX, ballY;
        let ballSpeedX, ballSpeedY;
        let paddleLeftY, paddleRightY; // paddleLeftY = AI, paddleRightY = Player
        let scoreLeft = 0;  // AI Score
        let scoreRight = 0; // Player Score

        let gameRunning = false;
        let resetTimeoutId = null; // To store timeout ID if needed

        // --- Constants ---
        const PADDLE_HEIGHT = paddleRight.offsetHeight;
        const BALL_SIZE = ball.offsetWidth;
        const GAME_WIDTH = gameArea.offsetWidth;
        const GAME_HEIGHT = gameArea.offsetHeight;
        const PLAYER_PADDLE_SPEED = 6;
        const AI_PADDLE_SPEED = 5.1;   // AI speed kept moderate
        const WINNING_SCORE = 10;
        // ***** BALL SPEED INCREASED *****
        const INITIAL_BALL_SPEED = 6.5; // Initial ball speed (MUCH FASTER start)
        const BALL_SPEED_INCREASE = 1.05; // Speed multiplier (gentle increase)
        // *******************************
        const MAX_BALL_SPEED_X_FACTOR = 3.2; // Max horizontal speed factor
        const MAX_BALL_SPEED_Y_FACTOR = 1.9; // Max vertical speed factor
        const POINT_RESET_DELAY = 1000; // Delay in ms after point scored

        // --- Functions ---

        // Reset ball to center with random direction
        function resetBall() {
            clearTimeout(resetTimeoutId);
            resetTimeoutId = null;
            ballX = GAME_WIDTH / 2 - BALL_SIZE / 2;
            ballY = GAME_HEIGHT / 2 - BALL_SIZE / 2;
            let angle = Math.random() * Math.PI / 2 - Math.PI / 4;
            ballSpeedX = INITIAL_BALL_SPEED * (Math.random() > 0.5 ? 1 : -1);
            ballSpeedY = INITIAL_BALL_SPEED * Math.sin(angle);
             // Ensure ball doesn't get stuck exactly horizontal or too slow vertically
             if (Math.abs(ballSpeedY) < 1.2) { // Increased min vertical speed
                 ballSpeedY = (Math.random() > 0.5 ? 1 : -1) * 1.2;
             }
             if(!gameRunning) {
                 ball.style.left = `${ballX}px`;
                 ball.style.top = `${ballY}px`;
             }
        }

        // Function to be called after delay to start next round
        function startNextRound() {
            resetBall();
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        }

         // Function to flash the score
         function flashScore(scoreElement) {
             scoreElement.classList.add('flash');
             setTimeout(() => {
                 scoreElement.classList.remove('flash');
             }, 300);
         }


        // Reset game state (for starting new game)
        function resetGame() {
             clearTimeout(resetTimeoutId);
             resetTimeoutId = null;
            scoreLeft = 0;
            scoreRight = 0;
            scoreLeftDisplay.textContent = scoreLeft;
            scoreRightDisplay.textContent = scoreRight;
            paddleLeftY = GAME_HEIGHT / 2 - PADDLE_HEIGHT / 2;
            paddleRightY = GAME_HEIGHT / 2 - PADDLE_HEIGHT / 2;
            paddleLeft.style.top = `${paddleLeftY}px`;
            paddleRight.style.top = `${paddleRightY}px`;
            resetBall();
            message.style.display = 'none';
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        }

        // Update game state each frame
        function gameLoop() {
            if (!gameRunning) return;

            // 1. Move Ball
            ballX += ballSpeedX;
            ballY += ballSpeedY;

            // 2. Ball Collision Detection
            if (ballY <= 0 || ballY >= GAME_HEIGHT - BALL_SIZE) {
                ballSpeedY *= -1;
                ballY = Math.max(0, Math.min(ballY, GAME_HEIGHT - BALL_SIZE));
                ballSpeedX += (Math.random() - 0.5) * 0.1;
            }

            const maxHorizontalSpeed = INITIAL_BALL_SPEED * MAX_BALL_SPEED_X_FACTOR;
            const maxVerticalSpeed = INITIAL_BALL_SPEED * MAX_BALL_SPEED_Y_FACTOR;

            if (ballX <= 20 + BALL_SIZE / 2 && ballX > 10 && ballY + BALL_SIZE > paddleLeftY && ballY < paddleLeftY + PADDLE_HEIGHT) {
                ballX = 20 + BALL_SIZE / 2;
                let nextSpeedX = ballSpeedX * -BALL_SPEED_INCREASE;
                if(Math.abs(nextSpeedX) > maxHorizontalSpeed) { nextSpeedX = Math.sign(nextSpeedX) * maxHorizontalSpeed; }
                ballSpeedX = nextSpeedX;
                let deltaY = ballY + BALL_SIZE / 2 - (paddleLeftY + PADDLE_HEIGHT / 2);
                ballSpeedY = deltaY * 0.16;
                ballSpeedY = Math.max(-maxVerticalSpeed, Math.min(ballSpeedY, maxVerticalSpeed));
            }
            else if (ballX >= GAME_WIDTH - 20 - BALL_SIZE * 1.5 && ballX < GAME_WIDTH - 10 && ballY + BALL_SIZE > paddleRightY && ballY < paddleRightY + PADDLE_HEIGHT) {
                ballX = GAME_WIDTH - 20 - BALL_SIZE * 1.5;
                let nextSpeedX = ballSpeedX * -BALL_SPEED_INCREASE;
                 if(Math.abs(nextSpeedX) > maxHorizontalSpeed) { nextSpeedX = Math.sign(nextSpeedX) * maxHorizontalSpeed; }
                ballSpeedX = nextSpeedX;
                let deltaY = ballY + BALL_SIZE / 2 - (paddleRightY + PADDLE_HEIGHT / 2);
                ballSpeedY = deltaY * 0.16;
                ballSpeedY = Math.max(-maxVerticalSpeed, Math.min(ballSpeedY, maxVerticalSpeed));
            }

             let pointScored = false;
             let scorerElement = null;

            if (ballX < 0) {
                scoreRight++;
                scoreRightDisplay.textContent = scoreRight;
                pointScored = true;
                scorerElement = scoreRightDisplay;
            } else if (ballX > GAME_WIDTH) {
                scoreLeft++;
                scoreLeftDisplay.textContent = scoreLeft;
                pointScored = true;
                scorerElement = scoreLeftDisplay;
            }

            if (pointScored) {
                gameRunning = false;
                flashScore(scorerElement);
                if (!checkWin()) {
                   resetTimeoutId = setTimeout(startNextRound, POINT_RESET_DELAY);
                }
                return;
            }

            // 3. Move Paddles
            let targetPaddleLeftY = ballY - PADDLE_HEIGHT / 2;
            let dy = targetPaddleLeftY - paddleLeftY;
            if (Math.abs(dy) > AI_PADDLE_SPEED) { paddleLeftY += Math.sign(dy) * AI_PADDLE_SPEED; }
            else { paddleLeftY += dy; }
            paddleLeftY = Math.max(0, Math.min(paddleLeftY, GAME_HEIGHT - PADDLE_HEIGHT));

            // 4. Update Positions in DOM
            ball.style.left = `${ballX}px`;
            ball.style.top = `${ballY}px`;
            paddleLeft.style.top = `${paddleLeftY}px`;
            paddleRight.style.top = `${paddleRightY}px`;

            // 5. Request Next Frame
            if (gameRunning) {
                requestAnimationFrame(gameLoop);
            }
        }

         // Check for win condition - Returns true if game is over
        function checkWin() {
            let gameOver = false;
            if (scoreRight >= WINNING_SCORE) {
                message.innerHTML = `You Win ${scoreRight} - ${scoreLeft}!<br>Click/Tap to Play Again`;
                message.style.display = 'block';
                gameOver = true;
            } else if (scoreLeft >= WINNING_SCORE) {
                message.innerHTML = `AI Wins ${scoreLeft} - ${scoreRight}!<br>Click/Tap to Play Again`;
                message.style.display = 'block';
                gameOver = true;
            }
             return gameOver;
        }

        // --- Event Listeners ---
        gameArea.addEventListener('mousemove', (e) => {
            let rect = gameArea.getBoundingClientRect();
            let mouseY = e.clientY - rect.top;
            paddleRightY = mouseY - PADDLE_HEIGHT / 2;
            paddleRightY = Math.max(0, Math.min(paddleRightY, GAME_HEIGHT - PADDLE_HEIGHT));
        });

        gameArea.addEventListener('touchmove', (e) => {
            e.preventDefault();
             if (e.touches.length > 0) {
                let rect = gameArea.getBoundingClientRect();
                let touchY = e.touches[0].clientY - rect.top;
                paddleRightY = touchY - PADDLE_HEIGHT / 2;
                paddleRightY = Math.max(0, Math.min(paddleRightY, GAME_HEIGHT - PADDLE_HEIGHT));
             }
        }, { passive: false });

        // Combined click handler for message and game area to start/restart
        function handleStartClick() {
             if (!gameRunning && message.style.display !== 'none') {
                 message.innerHTML = "First 10 points wins!<br>Click or Tap to Play"; // Reset msg text
                 resetGame(); // Start a fresh game
             } else if (!gameRunning && resetTimeoutId !== null) {
                  clearTimeout(resetTimeoutId);
                  startNextRound();
             }
        }

        message.addEventListener('click', handleStartClick);
        gameArea.addEventListener('click', (e) => {
             if (e.target !== message) {
                 handleStartClick();
             }
        });


        // --- Initial Setup ---
        paddleLeftY = GAME_HEIGHT / 2 - PADDLE_HEIGHT / 2;
        paddleRightY = GAME_HEIGHT / 2 - PADDLE_HEIGHT / 2;
        paddleLeft.style.top = `${paddleLeftY}px`;
        paddleRight.style.top = `${paddleRightY}px`;
        resetBall();

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Resize handling
            }, 250);
        });

    </script>

</body>
</html>